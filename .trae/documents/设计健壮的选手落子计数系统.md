# 选手落子计数系统设计

## 1. 系统概述

设计一个健壮的选手落子计数系统，用于精确维护和管理选手在游戏过程中的落子次数，能够准确处理各类影响落子次数或顺序的道具效果，解决多道具连续触发可能导致的落子次数计算错误问题。

## 2. 核心需求分析

### 2.1 道具效果分析
- **加速落子**：当前玩家获得额外1次落子机会
- **策略指引**：当前玩家获得额外1次落子机会，并推荐3个最优落子位置
- **手滑惩罚**：限制对手只能从随机3个位置中选择落子，不影响落子次数
- **对手加速**：对手获得额外1次落子机会

### 2.2 核心功能需求
- 实时跟踪选手原始落子次数
- 记录各类道具触发时间及影响值
- 动态计算道具叠加效果
- 维护当前有效落子次数
- 提供落子历史记录查询接口
- 确保多道具连续触发场景下的计算准确性和数据一致性
- 设计合理的数据结构存储落子事件与道具影响关系
- 实现落子次数的实时更新与校验机制
- 处理异常情况

## 3. 数据结构设计

### 3.1 落子事件记录
```typescript
interface MoveEvent {
  moveId: string;           // 落子事件ID
  timestamp: number;        // 事件发生时间戳
  player: Player;           // 玩家
  type: MoveEventType;      // 事件类型：NORMAL_MOVE | EXTRA_MOVE | ITEM_TRIGGER
  itemType?: ItemType;      // 道具类型（如果是道具触发）
  extraMovesAdded?: number; // 增加的额外落子次数
  description: string;      // 事件描述
}

enum MoveEventType {
  NORMAL_MOVE,   // 正常落子
  EXTRA_MOVE,    // 额外落子
  ITEM_TRIGGER   // 道具触发
}
```

### 3.2 选手落子计数状态
```typescript
interface PlayerMoveCount {
  player: Player;                // 玩家
  originalMoveCount: number;     // 原始落子次数（不考虑道具效果）
  extraMovesEarned: number;      // 获得的额外落子次数
  extraMovesUsed: number;        // 使用的额外落子次数
  currentExtraMoves: number;     // 当前剩余额外落子次数
  moveEvents: MoveEvent[];       // 落子事件历史记录
}
```

### 3.3 游戏落子计数状态
```typescript
interface GameMoveCountState {
  players: Map<Player, PlayerMoveCount>; // 各玩家落子计数状态
  currentPlayer: Player;                 // 当前玩家
  currentMoveEventId: string;            // 当前落子事件ID
}
```

## 4. 核心算法设计

### 4.1 初始化落子计数状态
```typescript
private initializeMoveCountState(): void {
  this.gameMoveCountState = {
    players: new Map([
      [Player.BLACK, this.createPlayerMoveCount(Player.BLACK)],
      [Player.WHITE, this.createPlayerMoveCount(Player.WHITE)]
    ]),
    currentPlayer: this.currentPlayer,
    currentMoveEventId: ''
  };
}

private createPlayerMoveCount(player: Player): PlayerMoveCount {
  return {
    player,
    originalMoveCount: 0,
    extraMovesEarned: 0,
    extraMovesUsed: 0,
    currentExtraMoves: 0,
    moveEvents: []
  };
}
```

### 4.2 记录落子事件
```typescript
private recordMoveEvent(type: MoveEventType, description: string, itemType?: ItemType, extraMovesAdded?: number): void {
  const event: MoveEvent = {
    moveId: this.generateMoveEventId(),
    timestamp: Date.now(),
    player: this.currentPlayer,
    type,
    itemType,
    extraMovesAdded,
    description
  };
  
  const playerMoveCount = this.gameMoveCountState.players.get(this.currentPlayer)!;
  playerMoveCount.moveEvents.push(event);
  this.gameMoveCountState.currentMoveEventId = event.moveId;
}
```

### 4.3 处理额外落子机会
```typescript
private addExtraMove(player: Player, source: string, itemType?: ItemType): void {
  const playerMoveCount = this.gameMoveCountState.players.get(player)!;
  playerMoveCount.extraMovesEarned++;
  playerMoveCount.currentExtraMoves++;
  
  this.recordMoveEvent(
    MoveEventType.ITEM_TRIGGER,
    `${source}增加1次额外落子机会`,
    itemType,
    1
  );
}
```

### 4.4 处理落子事件
```typescript
private processMoveEvent(): void {
  const playerMoveCount = this.gameMoveCountState.players.get(this.currentPlayer)!;
  
  if (this.hasExtraMove) {
    // 使用额外落子机会
    playerMoveCount.extraMovesUsed++;
    playerMoveCount.currentExtraMoves--;
    
    this.recordMoveEvent(
      MoveEventType.EXTRA_MOVE,
      '使用额外落子机会'
    );
    
    // 清除额外落子标记
    this.hasExtraMove = false;
  } else {
    // 正常落子
    playerMoveCount.originalMoveCount++;
    
    this.recordMoveEvent(
      MoveEventType.NORMAL_MOVE,
      '正常落子'
    );
    
    // 切换玩家
    this.currentPlayer = this.currentPlayer === Player.BLACK ? Player.WHITE : Player.WHITE;
    
    // 处理对手加速效果
    if (this.nextPlayerHasExtraMove) {
      this.addExtraMove(this.currentPlayer, '对手加速', ItemType.OPPONENT_ACCELERATION);
      this.nextPlayerHasExtraMove = false;
      this.hasExtraMove = true;
    }
  }
  
  // 更新当前玩家
  this.gameMoveCountState.currentPlayer = this.currentPlayer;
}
```

### 4.5 校验落子次数一致性
```typescript
private validateMoveCountConsistency(): boolean {
  for (const [player, moveCount] of this.gameMoveCountState.players) {
    const calculatedExtraMoves = moveCount.extraMovesEarned - moveCount.extraMovesUsed;
    if (calculatedExtraMoves !== moveCount.currentExtraMoves) {
      // 发现不一致，修复
      moveCount.currentExtraMoves = calculatedExtraMoves;
      return false;
    }
  }
  return true;
}
```

## 5. 集成到现有游戏逻辑

### 5.1 初始化落子计数系统
在游戏开始时初始化落子计数状态：
```typescript
startNewGame(): void {
  // ... 现有初始化逻辑
  this.initializeMoveCountState();
}
```

### 5.2 处理道具效果
在触发道具效果时，更新落子计数：
```typescript
triggerItemEffect(itemType: ItemType, player: Player): void {
  switch (itemType) {
    case ItemType.ACCELERATED_MOVE:
      this.hasExtraMove = true;
      this.addExtraMove(player, '加速落子', ItemType.ACCELERATED_MOVE);
      break;
    case ItemType.STRATEGY_GUIDE:
      this.showStrategyGuide(player);
      this.hasExtraMove = true;
      this.addExtraMove(player, '策略指引', ItemType.STRATEGY_GUIDE);
      break;
    case ItemType.OPPONENT_ACCELERATION:
      this.nextPlayerHasExtraMove = true;
      break;
    // ... 其他道具处理
  }
}
```

### 5.3 处理落子
在玩家落子后，更新落子计数：
```typescript
makeMove(position: Position): boolean {
  // ... 现有落子逻辑
  
  // 处理落子事件
  this.processMoveEvent();
  
  // 校验落子次数一致性
  this.validateMoveCountConsistency();
  
  return true;
}
```

## 6. 接口设计

### 6.1 获取玩家落子计数状态
```typescript
getPlayerMoveCount(player: Player): PlayerMoveCount {
  return { ...this.gameMoveCountState.players.get(player)! };
}
```

### 6.2 获取当前玩家落子计数状态
```typescript
getCurrentPlayerMoveCount(): PlayerMoveCount {
  return this.getPlayerMoveCount(this.currentPlayer);
}
```

### 6.3 获取落子历史记录
```typescript
getMoveHistory(): MoveEvent[] {
  const allEvents: MoveEvent[] = [];
  for (const [player, moveCount] of this.gameMoveCountState.players) {
    allEvents.push(...moveCount.moveEvents);
  }
  return allEvents.sort((a, b) => a.timestamp - b.timestamp);
}
```

### 6.4 获取玩家当前剩余额外落子次数
```typescript
getPlayerRemainingExtraMoves(player: Player): number {
  return this.gameMoveCountState.players.get(player)!.currentExtraMoves;
}
```

## 7. 异常处理策略

### 7.1 数据不一致处理
- 定期校验落子次数一致性
- 发现不一致时自动修复
- 记录修复事件

### 7.2 道具效果冲突处理
- 建立道具效果优先级机制
- 记录冲突事件
- 提供冲突解决方案

### 7.3 重复落子处理
- 记录重复落子尝试
- 忽略无效落子
- 维护落子事件唯一性

## 8. 测试策略

### 8.1 单元测试
- 测试各个核心算法
- 测试数据结构完整性
- 测试异常处理机制

### 8.2 集成测试
- 测试与现有游戏逻辑的集成
- 测试各类道具效果的处理
- 测试多道具连续触发场景

### 8.3 边界测试
- 测试极端情况下的落子次数计算
- 测试大量道具连续触发场景
- 测试游戏长时间运行后的性能

## 9. 性能优化

### 9.1 事件记录优化
- 使用高效的事件ID生成算法
- 限制事件历史记录长度
- 提供事件记录清理机制

### 9.2 计算优化
- 缓存计算结果
- 减少不必要的计算
- 优化数据结构访问

### 9.3 内存优化
- 使用高效的数据结构
- 及时清理无用数据
- 优化对象创建

## 10. 实施计划

1. 设计数据结构和核心算法
2. 实现落子计数系统核心功能
3. 集成到现有游戏逻辑
4. 实现接口设计
5. 编写单元测试
6. 进行集成测试
7. 优化性能
8. 完善文档

## 11. 预期效果

- 精确维护选手落子次数
- 准确处理各类道具效果
- 解决多道具连续触发导致的落子次数计算错误
- 提供完整的落子历史记录
- 确保落子次数计算的准确性和数据一致性
- 具备异常处理机制
- 提供丰富的查询接口

这个设计方案能够满足用户需求，提供一个健壮的选手落子计数系统，确保在各种复杂场景下都能准确维护和管理选手的落子次数。